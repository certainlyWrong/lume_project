// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

LumeImageInfo getImageInfo({required List<int> imageBytes}) =>
    RustLib.instance.api.crateApiImageOpsGetImageInfo(imageBytes: imageBytes);

Uint8List resize({
  required List<int> imageBytes,
  required int width,
  required int height,
  required bool keepAspectRatio,
}) => RustLib.instance.api.crateApiImageOpsResize(
  imageBytes: imageBytes,
  width: width,
  height: height,
  keepAspectRatio: keepAspectRatio,
);

Uint8List resizeWithFilter({
  required List<int> imageBytes,
  required int width,
  required int height,
  required String filter,
}) => RustLib.instance.api.crateApiImageOpsResizeWithFilter(
  imageBytes: imageBytes,
  width: width,
  height: height,
  filter: filter,
);

Uint8List crop({
  required List<int> imageBytes,
  required int x,
  required int y,
  required int width,
  required int height,
}) => RustLib.instance.api.crateApiImageOpsCrop(
  imageBytes: imageBytes,
  x: x,
  y: y,
  width: width,
  height: height,
);

Uint8List rotate({required List<int> imageBytes, required int degrees}) =>
    RustLib.instance.api.crateApiImageOpsRotate(
      imageBytes: imageBytes,
      degrees: degrees,
    );

Uint8List flipHorizontal({required List<int> imageBytes}) =>
    RustLib.instance.api.crateApiImageOpsFlipHorizontal(imageBytes: imageBytes);

Uint8List flipVertical({required List<int> imageBytes}) =>
    RustLib.instance.api.crateApiImageOpsFlipVertical(imageBytes: imageBytes);

Uint8List grayscale({required List<int> imageBytes}) =>
    RustLib.instance.api.crateApiImageOpsGrayscale(imageBytes: imageBytes);

Uint8List adjustBrightness({
  required List<int> imageBytes,
  required int value,
}) => RustLib.instance.api.crateApiImageOpsAdjustBrightness(
  imageBytes: imageBytes,
  value: value,
);

Uint8List adjustContrast({
  required List<int> imageBytes,
  required double value,
}) => RustLib.instance.api.crateApiImageOpsAdjustContrast(
  imageBytes: imageBytes,
  value: value,
);

Uint8List blur({required List<int> imageBytes, required double sigma}) =>
    RustLib.instance.api.crateApiImageOpsBlur(
      imageBytes: imageBytes,
      sigma: sigma,
    );

Uint8List sharpen({
  required List<int> imageBytes,
  required double sigma,
  required int threshold,
}) => RustLib.instance.api.crateApiImageOpsSharpen(
  imageBytes: imageBytes,
  sigma: sigma,
  threshold: threshold,
);

Uint8List invertColors({required List<int> imageBytes}) =>
    RustLib.instance.api.crateApiImageOpsInvertColors(imageBytes: imageBytes);

Uint8List huerotate({required List<int> imageBytes, required int degrees}) =>
    RustLib.instance.api.crateApiImageOpsHuerotate(
      imageBytes: imageBytes,
      degrees: degrees,
    );

Uint8List convertFormat({
  required List<int> imageBytes,
  required String targetFormat,
}) => RustLib.instance.api.crateApiImageOpsConvertFormat(
  imageBytes: imageBytes,
  targetFormat: targetFormat,
);

Uint8List thumbnail({
  required List<int> imageBytes,
  required int maxWidth,
  required int maxHeight,
}) => RustLib.instance.api.crateApiImageOpsThumbnail(
  imageBytes: imageBytes,
  maxWidth: maxWidth,
  maxHeight: maxHeight,
);

Uint8List thumbnailExact({
  required List<int> imageBytes,
  required int width,
  required int height,
}) => RustLib.instance.api.crateApiImageOpsThumbnailExact(
  imageBytes: imageBytes,
  width: width,
  height: height,
);

Uint8List overlay({
  required List<int> baseBytes,
  required List<int> overlayBytes,
  required PlatformInt64 x,
  required PlatformInt64 y,
}) => RustLib.instance.api.crateApiImageOpsOverlay(
  baseBytes: baseBytes,
  overlayBytes: overlayBytes,
  x: x,
  y: y,
);

Uint8List tile({
  required List<int> imageBytes,
  required int cols,
  required int rows,
}) => RustLib.instance.api.crateApiImageOpsTile(
  imageBytes: imageBytes,
  cols: cols,
  rows: rows,
);

Uint8List createBlank({
  required int width,
  required int height,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageOpsCreateBlank(
  width: width,
  height: height,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List extractChannel({
  required List<int> imageBytes,
  required int channel,
}) => RustLib.instance.api.crateApiImageOpsExtractChannel(
  imageBytes: imageBytes,
  channel: channel,
);

LumeColor getPixel({
  required List<int> imageBytes,
  required int x,
  required int y,
}) => RustLib.instance.api.crateApiImageOpsGetPixel(
  imageBytes: imageBytes,
  x: x,
  y: y,
);

class LumeColor {
  final int r;
  final int g;
  final int b;
  final int a;

  const LumeColor({
    required this.r,
    required this.g,
    required this.b,
    required this.a,
  });

  @override
  int get hashCode => r.hashCode ^ g.hashCode ^ b.hashCode ^ a.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LumeColor &&
          runtimeType == other.runtimeType &&
          r == other.r &&
          g == other.g &&
          b == other.b &&
          a == other.a;
}

class LumeImageInfo {
  final int width;
  final int height;
  final String format;
  final int sizeBytes;

  const LumeImageInfo({
    required this.width,
    required this.height,
    required this.format,
    required this.sizeBytes,
  });

  @override
  int get hashCode =>
      width.hashCode ^ height.hashCode ^ format.hashCode ^ sizeBytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LumeImageInfo &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          format == other.format &&
          sizeBytes == other.sizeBytes;
}
