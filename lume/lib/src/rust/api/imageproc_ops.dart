// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Uint8List gaussianBlur({
  required List<int> imageBytes,
  required double sigma,
}) => RustLib.instance.api.crateApiImageprocOpsGaussianBlur(
  imageBytes: imageBytes,
  sigma: sigma,
);

Uint8List medianFilter({
  required List<int> imageBytes,
  required int xRadius,
  required int yRadius,
}) => RustLib.instance.api.crateApiImageprocOpsMedianFilter(
  imageBytes: imageBytes,
  xRadius: xRadius,
  yRadius: yRadius,
);

Uint8List bilateralFilter({
  required List<int> imageBytes,
  required int windowSize,
  required double sigmaColor,
  required double sigmaSpatial,
}) => RustLib.instance.api.crateApiImageprocOpsBilateralFilter(
  imageBytes: imageBytes,
  windowSize: windowSize,
  sigmaColor: sigmaColor,
  sigmaSpatial: sigmaSpatial,
);

Uint8List boxFilter({
  required List<int> imageBytes,
  required int xRadius,
  required int yRadius,
}) => RustLib.instance.api.crateApiImageprocOpsBoxFilter(
  imageBytes: imageBytes,
  xRadius: xRadius,
  yRadius: yRadius,
);

Uint8List sharpen3X3({required List<int> imageBytes}) =>
    RustLib.instance.api.crateApiImageprocOpsSharpen3X3(imageBytes: imageBytes);

Uint8List sharpenGaussian({
  required List<int> imageBytes,
  required double sigma,
  required double amount,
}) => RustLib.instance.api.crateApiImageprocOpsSharpenGaussian(
  imageBytes: imageBytes,
  sigma: sigma,
  amount: amount,
);

Uint8List laplacianFilter({required List<int> imageBytes}) => RustLib
    .instance
    .api
    .crateApiImageprocOpsLaplacianFilter(imageBytes: imageBytes);

Uint8List canny({
  required List<int> imageBytes,
  required double lowThreshold,
  required double highThreshold,
}) => RustLib.instance.api.crateApiImageprocOpsCanny(
  imageBytes: imageBytes,
  lowThreshold: lowThreshold,
  highThreshold: highThreshold,
);

Uint8List sobelGradients({required List<int> imageBytes}) => RustLib
    .instance
    .api
    .crateApiImageprocOpsSobelGradients(imageBytes: imageBytes);

Uint8List adaptiveThreshold({
  required List<int> imageBytes,
  required int blockRadius,
}) => RustLib.instance.api.crateApiImageprocOpsAdaptiveThreshold(
  imageBytes: imageBytes,
  blockRadius: blockRadius,
);

Uint8List otsuThreshold({required List<int> imageBytes}) => RustLib.instance.api
    .crateApiImageprocOpsOtsuThreshold(imageBytes: imageBytes);

Uint8List threshold({
  required List<int> imageBytes,
  required int value,
  required bool invert,
}) => RustLib.instance.api.crateApiImageprocOpsThreshold(
  imageBytes: imageBytes,
  value: value,
  invert: invert,
);

Uint8List equalizeHistogram({required List<int> imageBytes}) => RustLib
    .instance
    .api
    .crateApiImageprocOpsEqualizeHistogram(imageBytes: imageBytes);

Uint8List stretchContrast({
  required List<int> imageBytes,
  required int inputLower,
  required int inputUpper,
  required int outputLower,
  required int outputUpper,
}) => RustLib.instance.api.crateApiImageprocOpsStretchContrast(
  imageBytes: imageBytes,
  inputLower: inputLower,
  inputUpper: inputUpper,
  outputLower: outputLower,
  outputUpper: outputUpper,
);

Uint8List dilate({required List<int> imageBytes, required int radius}) =>
    RustLib.instance.api.crateApiImageprocOpsDilate(
      imageBytes: imageBytes,
      radius: radius,
    );

Uint8List erode({required List<int> imageBytes, required int radius}) => RustLib
    .instance
    .api
    .crateApiImageprocOpsErode(imageBytes: imageBytes, radius: radius);

Uint8List morphologicalOpen({
  required List<int> imageBytes,
  required int radius,
}) => RustLib.instance.api.crateApiImageprocOpsMorphologicalOpen(
  imageBytes: imageBytes,
  radius: radius,
);

Uint8List morphologicalClose({
  required List<int> imageBytes,
  required int radius,
}) => RustLib.instance.api.crateApiImageprocOpsMorphologicalClose(
  imageBytes: imageBytes,
  radius: radius,
);

Uint8List rotateAboutCenter({
  required List<int> imageBytes,
  required double theta,
  required int bgR,
  required int bgG,
  required int bgB,
  required int bgA,
}) => RustLib.instance.api.crateApiImageprocOpsRotateAboutCenter(
  imageBytes: imageBytes,
  theta: theta,
  bgR: bgR,
  bgG: bgG,
  bgB: bgB,
  bgA: bgA,
);

Uint8List translate({
  required List<int> imageBytes,
  required int tx,
  required int ty,
}) => RustLib.instance.api.crateApiImageprocOpsTranslate(
  imageBytes: imageBytes,
  tx: tx,
  ty: ty,
);

Uint8List gaussianNoise({
  required List<int> imageBytes,
  required double mean,
  required double stddev,
  required BigInt seed,
}) => RustLib.instance.api.crateApiImageprocOpsGaussianNoise(
  imageBytes: imageBytes,
  mean: mean,
  stddev: stddev,
  seed: seed,
);

Uint8List saltAndPepperNoise({
  required List<int> imageBytes,
  required double rate,
  required BigInt seed,
}) => RustLib.instance.api.crateApiImageprocOpsSaltAndPepperNoise(
  imageBytes: imageBytes,
  rate: rate,
  seed: seed,
);

Uint8List seamCarveWidth({
  required List<int> imageBytes,
  required int newWidth,
}) => RustLib.instance.api.crateApiImageprocOpsSeamCarveWidth(
  imageBytes: imageBytes,
  newWidth: newWidth,
);

Uint8List drawLine({
  required List<int> imageBytes,
  required int x1,
  required int y1,
  required int x2,
  required int y2,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawLine(
  imageBytes: imageBytes,
  x1: x1,
  y1: y1,
  x2: x2,
  y2: y2,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawAntialiasedLine({
  required List<int> imageBytes,
  required int x1,
  required int y1,
  required int x2,
  required int y2,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawAntialiasedLine(
  imageBytes: imageBytes,
  x1: x1,
  y1: y1,
  x2: x2,
  y2: y2,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawHollowRect({
  required List<int> imageBytes,
  required int x,
  required int y,
  required int width,
  required int height,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawHollowRect(
  imageBytes: imageBytes,
  x: x,
  y: y,
  width: width,
  height: height,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawFilledRect({
  required List<int> imageBytes,
  required int x,
  required int y,
  required int width,
  required int height,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawFilledRect(
  imageBytes: imageBytes,
  x: x,
  y: y,
  width: width,
  height: height,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawHollowCircle({
  required List<int> imageBytes,
  required int cx,
  required int cy,
  required int radius,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawHollowCircle(
  imageBytes: imageBytes,
  cx: cx,
  cy: cy,
  radius: radius,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawFilledCircle({
  required List<int> imageBytes,
  required int cx,
  required int cy,
  required int radius,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawFilledCircle(
  imageBytes: imageBytes,
  cx: cx,
  cy: cy,
  radius: radius,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawHollowEllipse({
  required List<int> imageBytes,
  required int cx,
  required int cy,
  required int widthRadius,
  required int heightRadius,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawHollowEllipse(
  imageBytes: imageBytes,
  cx: cx,
  cy: cy,
  widthRadius: widthRadius,
  heightRadius: heightRadius,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawFilledEllipse({
  required List<int> imageBytes,
  required int cx,
  required int cy,
  required int widthRadius,
  required int heightRadius,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawFilledEllipse(
  imageBytes: imageBytes,
  cx: cx,
  cy: cy,
  widthRadius: widthRadius,
  heightRadius: heightRadius,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawFilledPolygon({
  required List<int> imageBytes,
  required List<LumePoint> points,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawFilledPolygon(
  imageBytes: imageBytes,
  points: points,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawHollowPolygon({
  required List<int> imageBytes,
  required List<LumePoint> points,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawHollowPolygon(
  imageBytes: imageBytes,
  points: points,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawCubicBezier({
  required List<int> imageBytes,
  required double startX,
  required double startY,
  required double endX,
  required double endY,
  required double ctrl1X,
  required double ctrl1Y,
  required double ctrl2X,
  required double ctrl2Y,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawCubicBezier(
  imageBytes: imageBytes,
  startX: startX,
  startY: startY,
  endX: endX,
  endY: endY,
  ctrl1X: ctrl1X,
  ctrl1Y: ctrl1Y,
  ctrl2X: ctrl2X,
  ctrl2Y: ctrl2Y,
  r: r,
  g: g,
  b: b,
  a: a,
);

Uint8List drawCross({
  required List<int> imageBytes,
  required int cx,
  required int cy,
  required int r,
  required int g,
  required int b,
  required int a,
}) => RustLib.instance.api.crateApiImageprocOpsDrawCross(
  imageBytes: imageBytes,
  cx: cx,
  cy: cy,
  r: r,
  g: g,
  b: b,
  a: a,
);

List<LumeContour> findContours({required List<int> imageBytes}) => RustLib
    .instance
    .api
    .crateApiImageprocOpsFindContours(imageBytes: imageBytes);

Uint8List distanceTransform({required List<int> imageBytes}) => RustLib
    .instance
    .api
    .crateApiImageprocOpsDistanceTransform(imageBytes: imageBytes);

class LumeContour {
  final List<LumePoint> points;
  final String borderType;
  final int parent;

  const LumeContour({
    required this.points,
    required this.borderType,
    required this.parent,
  });

  @override
  int get hashCode => points.hashCode ^ borderType.hashCode ^ parent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LumeContour &&
          runtimeType == other.runtimeType &&
          points == other.points &&
          borderType == other.borderType &&
          parent == other.parent;
}

class LumePoint {
  final int x;
  final int y;

  const LumePoint({required this.x, required this.y});

  @override
  int get hashCode => x.hashCode ^ y.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LumePoint &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y;
}
